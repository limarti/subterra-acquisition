# Fastlane configuration for iOS builds
# This file contains the build automation for TestFlight distribution

default_platform(:ios)

platform :ios do
  desc "Build iOS app without uploading"
  lane :build do
    # Path configuration - get absolute path
    fastlane_dir = File.dirname(File.expand_path(__FILE__))
    frontend_dir = File.expand_path("../..", fastlane_dir)
    ios_path = File.join(frontend_dir, "ios", "App")

    # Step 1: Setup keychain for CI environment
    keychain_name = "fastlane_keychain"
    keychain_password = ENV["KEYCHAIN_PASSWORD"]

    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: false,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    # Step 2: Import distribution certificate
    import_certificate(
      certificate_path: ENV["CERTIFICATE_PATH"],
      certificate_password: ENV["IOS_CERTIFICATE_PASSWORD"],
      keychain_name: keychain_name,
      keychain_password: keychain_password
    )

    # Step 3: Install provisioning profile
    install_provisioning_profile(
      path: ENV["PROVISIONING_PROFILE_PATH"]
    )

    # Step 4: Update build number
    increment_build_number(
      xcodeproj: "#{ios_path}/App.xcodeproj",
      build_number: ENV["BUILD_NUMBER"]
    )

    # Step 5: Update version number
    increment_version_number(
      xcodeproj: "#{ios_path}/App.xcodeproj",
      version_number: ENV["VERSION_NUMBER"]
    )

    # Step 6: Set encryption compliance (avoid manual prompt in TestFlight)
    set_info_plist_value(
      path: "#{ios_path}/App/Info.plist",
      key: "ITSAppUsesNonExemptEncryption",
      value: false
    )

    # Step 7: Configure code signing in Xcode project (ONLY for App target)
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "#{ios_path}/App.xcodeproj",
      team_id: ENV["APPLE_TEAM_ID"],
      code_sign_identity: "Apple Distribution",
      profile_uuid: ENV["PP_UUID"],
      targets: "App"  # ONLY update the App target, not Pods
    )

    # Step 8: Build and sign the app
    build_app(
      workspace: "#{ios_path}/App.xcworkspace",
      scheme: "App",
      configuration: "Release",
      export_method: "app-store",
      output_directory: "#{ios_path}/ipa-output",
      output_name: "gla-#{ENV['BUILD_ID']}.ipa",
      clean: true,
      export_options: {
        method: "app-store",
        teamID: ENV["APPLE_TEAM_ID"],
        uploadBitcode: false,
        uploadSymbols: true,
        provisioningProfiles: {
          "com.geolitix.gssi.gla" => ENV["PP_UUID"]
        }
      },
      buildlog_path: "#{ios_path}/buildlogs"
    )

    # Step 9: Cleanup keychain
    delete_keychain(
      name: keychain_name
    ) if is_ci
  end

  desc "Upload iOS app to TestFlight (requires pre-built IPA)"
  lane :upload do
    # Path configuration
    fastlane_dir = File.dirname(File.expand_path(__FILE__))
    frontend_dir = File.expand_path("../..", fastlane_dir)
    ios_path = File.join(frontend_dir, "ios", "App")
    ipa_output_dir = File.join(ios_path, "ipa-output")

    # Find the IPA file (supports any .ipa file in the directory)
    ipa_files = Dir.glob("#{ipa_output_dir}/*.ipa")

    if ipa_files.empty?
      UI.user_error!("No IPA file found in #{ipa_output_dir}")
    end

    ipa_file = File.expand_path(ipa_files.first)
    UI.message("=== IPA File Information ===")
    UI.message("ğŸ“¦ Found IPA: #{File.basename(ipa_file)}")
    UI.message("ğŸ“ Full IPA path: #{ipa_file}")
    UI.message("ğŸ“‚ IPA exists: #{File.exist?(ipa_file)}")
    UI.message("ğŸ“ IPA size: #{File.size(ipa_file)} bytes")
    UI.message("ğŸ” IPA readable: #{File.readable?(ipa_file)}")
    UI.message("ğŸ—‚ï¸  IPA parent dir exists: #{File.directory?(File.dirname(ipa_file))}")

    UI.message("\n=== Directory Information ===")
    UI.message("ğŸŒ Current working dir: #{Dir.pwd}")
    UI.message("ğŸ’¾ Temp dir (Dir.tmpdir): #{Dir.tmpdir}")
    UI.message("ğŸ’¾ Temp dir exists: #{File.directory?(Dir.tmpdir)}")
    UI.message("ğŸ’¾ Temp dir writable: #{File.writable?(Dir.tmpdir)}")

    UI.message("\n=== Environment Variables ===")
    UI.message("TMPDIR: #{ENV['TMPDIR'] || 'not set'}")
    UI.message("TEMP: #{ENV['TEMP'] || 'not set'}")
    UI.message("TMP: #{ENV['TMP'] || 'not set'}")
    UI.message("HOME: #{ENV['HOME'] || 'not set'}")
    UI.message("RUNNER_TEMP: #{ENV['RUNNER_TEMP'] || 'not set'}")

    UI.message("\n=== System Information ===")
    UI.message("Ruby version: #{RUBY_VERSION}")
    UI.message("Platform: #{RUBY_PLATFORM}")

    # Test temp directory access
    UI.message("\n=== Testing Temp Directory ===")
    begin
      test_dir = File.join(Dir.tmpdir, "fastlane_test_#{Time.now.to_i}")
      Dir.mkdir(test_dir)
      UI.message("âœ… Successfully created test dir: #{test_dir}")
      Dir.rmdir(test_dir)
      UI.message("âœ… Successfully removed test dir")
    rescue => e
      UI.error("âŒ Failed to create/remove temp dir: #{e.message}")
    end

    # Setup App Store Connect API key
    api_key = app_store_connect_api_key(
      key_id: ENV["APPLE_API_KEY_ID"],
      issuer_id: ENV["APPLE_API_ISSUER_ID"],
      key_filepath: ENV["API_KEY_PATH"]
    )

    # Upload to TestFlight
    UI.message("\n=== Starting Upload ===")
    UI.message("About to upload: #{ipa_file}")

    begin
      upload_to_testflight(
        api_key: api_key,
        skip_waiting_for_build_processing: true,
        skip_submission: true,
        ipa: ipa_file,
        distribute_external: false,
        notify_external_testers: false
      )
      UI.success("âœ… Upload completed successfully")
    rescue => e
      UI.error("âŒ Upload failed: #{e.class}")
      UI.error("Error message: #{e.message}")
      UI.error("Backtrace: #{e.backtrace.first(10).join("\n")}")
      raise e
    end
  end
end
